<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced JavaScript Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .widget {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .chart-container {
            height: 300px;
            position: relative;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connected { background-color: #4CAF50; }
        .status-disconnected { background-color: #f44336; }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric {
            text-align: center;
            padding: 15px;
            background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
            border-radius: 10px;
            box-shadow: inset 2px 2px 5px #d0d0d0, inset -2px -2px 5px #ffffff;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .metric-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        canvas {
            border-radius: 10px;
        }
        
        .data-table {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        th {
            background-color: #f8f9fa;
            font-weight: bold;
            position: sticky;
            top: 0;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            .controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Advanced JavaScript Analytics Dashboard</h1>
            <p>Real-time data visualization with complex algorithms</p>
        </header>
        
        <div class="controls">
            <button id="startBtn">Start Simulation</button>
            <button id="stopBtn">Stop Simulation</button>
            <button id="clearBtn">Clear Data</button>
            <button id="exportBtn">Export Data</button>
            <span id="connectionStatus">
                <span class="status-indicator status-disconnected"></span>
                Disconnected
            </span>
        </div>
        
        <div class="dashboard">
            <div class="widget">
                <h3>Real-time Line Chart</h3>
                <div class="chart-container">
                    <canvas id="lineChart"></canvas>
                </div>
            </div>
            
            <div class="widget">
                <h3>Performance Metrics</h3>
                <div class="metrics" id="metrics"></div>
            </div>
            
            <div class="widget">
                <h3>Data Distribution</h3>
                <div class="chart-container">
                    <canvas id="barChart"></canvas>
                </div>
            </div>
            
            <div class="widget">
                <h3>Live Data Feed</h3>
                <div class="data-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Timestamp</th>
                                <th>Value</th>
                                <th>Category</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="dataTable"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Advanced JavaScript Dashboard Implementation
        class DataAnalytics {
            constructor() {
                this.data = [];
                this.subscribers = new Map();
                this.isRunning = false;
                this.intervalId = null;
                this.chartInstances = new Map();
                this.metrics = {
                    totalEvents: 0,
                    avgValue: 0,
                    maxValue: 0,
                    minValue: Infinity,
                    variance: 0
                };
                
                this.init();
            }
            
            // Observer pattern implementation
            subscribe(event, callback) {
                if (!this.subscribers.has(event)) {
                    this.subscribers.set(event, []);
                }
                this.subscribers.get(event).push(callback);
            }
            
            notify(event, data) {
                if (this.subscribers.has(event)) {
                    this.subscribers.get(event).forEach(callback => callback(data));
                }
            }
            
            // Complex data generation with multiple algorithms
            generateDataPoint() {
                const timestamp = Date.now();
                const baseValue = Math.sin(timestamp / 10000) * 50;
                const noise = (Math.random() - 0.5) * 20;
                const trend = timestamp / 100000;
                const seasonal = Math.sin(timestamp / 5000) * 10;
                
                const value = baseValue + noise + trend + seasonal;
                const category = ['Alpha', 'Beta', 'Gamma', 'Delta'][Math.floor(Math.random() * 4)];
                const status = Math.random() > 0.8 ? 'Warning' : 'Normal';
                
                return {
                    id: this.generateUUID(),
                    timestamp: new Date(timestamp),
                    value: Math.round(value * 100) / 100,
                    category,
                    status,
                    processed: false
                };
            }
            
            generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }
            
            // Advanced statistical calculations
            calculateMetrics() {
                if (this.data.length === 0) return;
                
                const values = this.data.map(d => d.value);
                const sum = values.reduce((a, b) => a + b, 0);
                const avg = sum / values.length;
                
                this.metrics.totalEvents = this.data.length;
                this.metrics.avgValue = Math.round(avg * 100) / 100;
                this.metrics.maxValue = Math.max(...values);
                this.metrics.minValue = Math.min(...values);
                
                // Calculate variance
                const squaredDiffs = values.map(value => Math.pow(value - avg, 2));
                this.metrics.variance = Math.round((squaredDiffs.reduce((a, b) => a + b, 0) / values.length) * 100) / 100;
                
                this.notify('metricsUpdated', this.metrics);
            }
            
            // Data processing with worker simulation
            async processDataBatch(batchSize = 10) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const unprocessed = this.data.filter(d => !d.processed);
                        const batch = unprocessed.slice(0, batchSize);
                        
                        batch.forEach(item => {
                            item.processed = true;
                            item.processedAt = new Date();
                        });
                        
                        resolve(batch);
                    }, Math.random() * 100);
                });
            }
            
            // Advanced filtering and sorting
            getFilteredData(filters = {}) {
                let filtered = [...this.data];
                
                if (filters.category) {
                    filtered = filtered.filter(d => d.category === filters.category);
                }
                
                if (filters.status) {
                    filtered = filtered.filter(d => d.status === filters.status);
                }
                
                if (filters.dateRange) {
                    const { start, end } = filters.dateRange;
                    filtered = filtered.filter(d => d.timestamp >= start && d.timestamp <= end);
                }
                
                return filtered.sort((a, b) => b.timestamp - a.timestamp);
            }
            
            // Chart rendering with Canvas API
            renderLineChart(canvasId) {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                const rect = canvas.parentElement.getBoundingClientRect();
                
                canvas.width = rect.width;
                canvas.height = rect.height;
                
                const data = this.data.slice(-50); // Last 50 points
                if (data.length < 2) return;
                
                const padding = 40;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                
                const minValue = Math.min(...data.map(d => d.value));
                const maxValue = Math.max(...data.map(d => d.value));
                const valueRange = maxValue - minValue || 1;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const y = padding + (i / 10) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                }
                
                // Draw line
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                data.forEach((point, index) => {
                    const x = padding + (index / (data.length - 1)) * chartWidth;
                    const y = padding + (1 - (point.value - minValue) / valueRange) * chartHeight;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#764ba2';
                data.forEach((point, index) => {
                    const x = padding + (index / (data.length - 1)) * chartWidth;
                    const y = padding + (1 - (point.value - minValue) / valueRange) * chartHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Draw labels
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText(maxValue.toFixed(1), 10, padding + 5);
                ctx.fillText(minValue.toFixed(1), 10, canvas.height - padding + 5);
            }
            
            renderBarChart(canvasId) {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                const rect = canvas.parentElement.getBoundingClientRect();
                
                canvas.width = rect.width;
                canvas.height = rect.height;
                
                // Group data by category
                const categoryData = this.data.reduce((acc, item) => {
                    acc[item.category] = (acc[item.category] || 0) + 1;
                    return acc;
                }, {});
                
                const categories = Object.keys(categoryData);
                const values = Object.values(categoryData);
                const maxValue = Math.max(...values, 1);
                
                const padding = 40;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;
                const barWidth = chartWidth / categories.length * 0.8;
                const barSpacing = chartWidth / categories.length * 0.2;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw bars
                const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c'];
                
                categories.forEach((category, index) => {
                    const barHeight = (categoryData[category] / maxValue) * chartHeight;
                    const x = padding + index * (barWidth + barSpacing);
                    const y = canvas.height - padding - barHeight;
                    
                    ctx.fillStyle = colors[index % colors.length];
                    ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // Draw labels
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(category, x + barWidth / 2, canvas.height - 10);
                    ctx.fillText(categoryData[category], x + barWidth / 2, y - 5);
                });
            }
            
            updateMetricsDisplay() {
                const metricsContainer = document.getElementById('metrics');
                metricsContainer.innerHTML = `
                    <div class="metric">
                        <div class="metric-value">${this.metrics.totalEvents}</div>
                        <div class="metric-label">Total Events</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value">${this.metrics.avgValue}</div>
                        <div class="metric-label">Average</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value">${this.metrics.maxValue}</div>
                        <div class="metric-label">Maximum</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value">${this.metrics.minValue === Infinity ? 0 : this.metrics.minValue}</div>
                        <div class="metric-label">Minimum</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value">${this.metrics.variance}</div>
                        <div class="metric-label">Variance</div>
                    </div>
                `;
            }
            
            updateDataTable() {
                const tableBody = document.getElementById('dataTable');
                const recentData = this.data.slice(-10).reverse();
                
                tableBody.innerHTML = recentData.map(item => `
                    <tr>
                        <td>${item.timestamp.toLocaleTimeString()}</td>
                        <td>${item.value}</td>
                        <td>${item.category}</td>
                        <td style="color: ${item.status === 'Warning' ? '#f44336' : '#4CAF50'}">${item.status}</td>
                    </tr>
                `).join('');
            }
            
            // WebSocket simulation
            simulateDataStream() {
                this.intervalId = setInterval(() => {
                    const newDataPoint = this.generateDataPoint();
                    this.data.push(newDataPoint);
                    
                    // Keep only last 1000 points for performance
                    if (this.data.length > 1000) {
                        this.data = this.data.slice(-1000);
                    }
                    
                    this.calculateMetrics();
                    this.renderCharts();
                    this.updateDataTable();
                    
                    this.notify('dataReceived', newDataPoint);
                }, 200);
            }
            
            renderCharts() {
                this.renderLineChart('lineChart');
                this.renderBarChart('barChart');
            }
            
            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    this.simulateDataStream();
                    this.updateConnectionStatus(true);
                }
            }
            
            stop() {
                if (this.isRunning) {
                    this.isRunning = false;
                    clearInterval(this.intervalId);
                    this.updateConnectionStatus(false);
                }
            }
            
            clear() {
                this.data = [];
                this.metrics = {
                    totalEvents: 0,
                    avgValue: 0,
                    maxValue: 0,
                    minValue: Infinity,
                    variance: 0
                };
                this.renderCharts();
                this.updateMetricsDisplay();
                this.updateDataTable();
            }
            
            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                const indicator = statusElement.querySelector('.status-indicator');
                
                if (connected) {
                    indicator.className = 'status-indicator status-connected';
                    statusElement.childNodes[2].textContent = 'Connected';
                } else {
                    indicator.className = 'status-indicator status-disconnected';
                    statusElement.childNodes[2].textContent = 'Disconnected';
                }
            }
            
            exportData() {
                const exportData = {
                    timestamp: new Date(),
                    data: this.data,
                    metrics: this.metrics
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `analytics-export-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            init() {
                // Set up event listeners
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('clearBtn').addEventListener('click', () => this.clear());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportData());
                
                // Subscribe to events
                this.subscribe('metricsUpdated', () => this.updateMetricsDisplay());
                this.subscribe('dataReceived', (data) => {
                    console.log('New data received:', data);
                });
                
                // Initialize display
                this.updateMetricsDisplay();
                this.renderCharts();
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    setTimeout(() => this.renderCharts(), 100);
                });
            }
        }
        
        // Initialize the application
        const analytics = new DataAnalytics();
        
        // Add some demo functionality
        setTimeout(() => {
            console.log('Dashboard initialized successfully');
            console.log('Available methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(analytics)));
        }, 1000);
    </script>
</body>
</html>